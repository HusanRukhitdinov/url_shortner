package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"os"
	"strings"
)

const (
	SqlcDir    = "internal/repo/sqlc"
	OutputFile = "internal/repo/storage/storage.generated.go"
)

func main() {
	moduleName := getModuleName()
	querierPath := fmt.Sprintf("%s/querier.go", SqlcDir)

	fmt.Println("--> 1. Reading sqlc generated file:", querierPath)

	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, querierPath, nil, parser.ParseComments)
	if err != nil {
		fmt.Printf("ERROR: File %s not found. Run 'sqlc generate' first.\n", querierPath)
		os.Exit(1)
	}

	interfaceGroups := make(map[string][]string)

	ast.Inspect(node, func(n ast.Node) bool {
		typeSpec, ok := n.(*ast.TypeSpec)
		if !ok || typeSpec.Name.Name != "Querier" {
			return true
		}

		interfaceType, ok := typeSpec.Type.(*ast.InterfaceType)
		if !ok {
			return true
		}

		for _, method := range interfaceType.Methods.List {
			if len(method.Names) == 0 {
				continue
			}
			methodName := method.Names[0].Name

			if funcType, ok := method.Type.(*ast.FuncType); ok {
				if funcType.Params != nil {
					for _, field := range funcType.Params.List {
						fixType(field.Type)
					}
				}
				if funcType.Results != nil {
					for _, field := range funcType.Results.List {
						fixType(field.Type)
					}
				}
			}

			var buf bytes.Buffer
			printer.Fprint(&buf, fset, method.Type)
			signature := buf.String()
			signature = strings.TrimPrefix(signature, "func")

			fullMethod := fmt.Sprintf("%s%s", methodName, signature)

			targetInterface := "DefaultRepositoryI"
			if method.Doc != nil {
				for _, comment := range method.Doc.List {
					if strings.Contains(comment.Text, "@interface") {
						parts := strings.Fields(comment.Text)
						for i, part := range parts {
							if part == "@interface" && i+1 < len(parts) {
								targetInterface = parts[i+1]
							}
						}
					}
				}
			}
			interfaceGroups[targetInterface] = append(interfaceGroups[targetInterface], fullMethod)
		}
		return false
	})

	fmt.Println("--> 2. Generating storage file...")
	generateFile(moduleName, interfaceGroups)
}

func fixType(expr ast.Expr) {
	switch t := expr.(type) {
	case *ast.Ident:
		if !isBuiltinType(t.Name) {
			t.Name = "sqlc." + t.Name
		}
	case *ast.StarExpr:
		fixType(t.X)
	case *ast.ArrayType:
		fixType(t.Elt)
	}
}

func isBuiltinType(name string) bool {
	switch name {
	case "error", "int", "int32", "int64", "string", "bool", "byte", "any", "nil", "Context":
		return true
	}
	return false
}

func generateFile(moduleName string, groups map[string][]string) {
	var sb strings.Builder

	sb.WriteString("// Code generated by tools/sqlc-gen-custom. DO NOT EDIT.\n")
	sb.WriteString("package storage\n\n")

	sb.WriteString("import (\n")
	sb.WriteString("\t\"context\"\n")
	sb.WriteString("\t\"github.com/google/uuid\"\n")
	sb.WriteString("\t\"github.com/jackc/pgx/v5/pgtype\"\n")
	sb.WriteString("\t redis \"github.com/redis/go-redis/v9\"\n")
	sb.WriteString("\t cache \"github.com/go-redis/cache/v9\"\n")
	sb.WriteString(fmt.Sprintf("\t\"%s/%s\"\n", moduleName, SqlcDir))
	sb.WriteString(fmt.Sprintf("\t\"%s/pkg/postgres\"\n", moduleName))
	sb.WriteString(")\n\n")

	sb.WriteString("type StorageI interface {\n")
	sb.WriteString("\tClose()\n")
	sb.WriteString("\tCache() *cache.Cache\n")
	sb.WriteString("\tWithinTransaction(ctx context.Context, fn func(StorageI) error) error\n")
	for iName := range groups {
		methodName := strings.TrimSuffix(iName, "RepositoryI")
		sb.WriteString(fmt.Sprintf("\t%s() %s\n", methodName, iName))
	}
	sb.WriteString("}\n\n")

	for iName, methods := range groups {
		sb.WriteString(fmt.Sprintf("type %s interface {\n", iName))
		for _, m := range methods {
			sb.WriteString(fmt.Sprintf("\t%s\n", m))
		}
		sb.WriteString("}\n\n")
	}

	sb.WriteString("type storageImpl struct {\n")
	sb.WriteString("\t*sqlc.Queries\n")
	sb.WriteString("\tpg *postgres.Postgres\n")
	sb.WriteString("\trds *redis.Client\n")
	sb.WriteString("\tcache *cache.Cache\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func NewStorage(pg *postgres.Postgres, rds *redis.Client, cache *cache.Cache) StorageI {\n")
	sb.WriteString("\treturn &storageImpl{\n")
	sb.WriteString("\t\tQueries: sqlc.New(pg.Pool),\n")
	sb.WriteString("\t\tpg:      pg,\n")
	sb.WriteString("\t\trds:     rds,\n")
	sb.WriteString("\t\tcache:   cache,\n")
	sb.WriteString("\t}\n")
	sb.WriteString("}\n\n")

	sb.WriteString("func (s *storageImpl) Close() { s.pg.Close() }\n")
	sb.WriteString("func (s *storageImpl) Cache() *cache.Cache { return s.cache }\n\n")

	sb.WriteString(`func (s *storageImpl) WithinTransaction(ctx context.Context, fn func(StorageI) error) error {
	tx, err := s.pg.Pool.Begin(ctx)
	if err != nil {
		return err
	}
	
	defer tx.Rollback(ctx)

	qtx := s.Queries.WithTx(tx)
	err = fn(&storageImpl{Queries: qtx, pg: s.pg, rds: s.rds, cache: s.cache})
	if err != nil {
		return err
	}

	return tx.Commit(ctx)
}

`)

	for iName := range groups {
		methodName := strings.TrimSuffix(iName, "RepositoryI")
		sb.WriteString(fmt.Sprintf("func (s *storageImpl) %s() %s { return s }\n", methodName, iName))
	}

	err := os.WriteFile(OutputFile, []byte(sb.String()), 0644)
	if err != nil {
		fmt.Printf("ERROR: Could not write file: %v\n", err)
		os.Exit(1)
	}
	fmt.Println("--> 3. Successfully generated:", OutputFile)
}

func getModuleName() string {
	file, err := os.Open("go.mod")
	if err != nil {
		return "module"
	}
	defer file.Close()
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "module ") {
			return strings.TrimSpace(strings.TrimPrefix(line, "module "))
		}
	}
	return "module"
}
